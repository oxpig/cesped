<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>cesped.evaluateEntry API documentation</title>
<meta name="description" content="This module allows for benchmark entry evaluation given the inferred poses." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cesped.evaluateEntry</code></h1>
</header>
<section id="section-intro">
<p>This module allows for benchmark entry evaluation given the inferred poses.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module allows for benchmark entry evaluation given the inferred poses.
&#34;&#34;&#34;
import json
import os
import shutil
import subprocess
import os.path as osp
import tempfile
from typing import Literal, Optional, Tuple, Union, Dict

import mrcfile
import numpy as np
import starfile

from cesped.constants import RELION_ANGLES_NAMES, RELION_SHIFTS_NAMES, RELION_PRED_POSE_CONFIDENCE_NAME, \
    RELION_ORI_POSE_CONFIDENCE_NAME, defaultBenchmarkDir, relionBinDir, mpirunCmd, relionSingularity, RELION_IMAGE_FNAME
from cesped.particlesDataset import ParticlesDataset
from cesped.utils.anglesStats import computeAngularError
from cesped.utils.volumeStats import compute_stats
from cesped.zenodo.downloadFromZenodo import download_mask


class Evaluator():

    def __init__(self, predictionType: Literal[&#34;S2&#34;, &#34;SO3&#34;, &#34;SO3xR2&#34;], usePredConfidence: bool = True,
                 benchmarkDir: Union[str, os.PathLike] = defaultBenchmarkDir,
                 relionBinDir:Optional[str]=relionBinDir, mpirun:Optional[str]=mpirunCmd,
                 relionSingularity:Optional[str]=relionSingularity,
                 n_cpus=1, wdir=None, verbose=True, use_gt_mask=True):
        &#34;&#34;&#34;

        Args:
            predictionType (Literal[S2, SO3, SO3xR2]): The type of the predicted pose. S2 if only \
                the first two euler angles were predicted (cones). SO3 if all the 3 euler angles were predicted. \
                SO3xR2 if both the euler angles and the particle shifts (translations) were predicted. Depending on the
                type of prediction, the ground-truth values will be used to fill in the missing information            usePredConfidence:
            benchmarkDir (str): The root directory where the datasets are downloaded.
            relionBinDir (Optional[str]): The Relion bin directory. If not provided, it is read from configs/defaultRelionConfig.yaml
            mpirun (Optional[str]): The mpriun command. Required inf n_cpus &gt;1. If not provided, it is read from configs/defaultRelionConfig.yaml
            relionSingularity (Optional[str]): A built singularity image from relionSingularity.def that let you install and run relion easily
            n_cpus (int): The number of cpus used in the calculations
            wdir (str): The directory where intermediate results will be saved. It acts as a cache as well
            verbose (bool): Print to stdout? Set it to true if using via command line
            use_gt_mask (bool): Should computations use ground-truth masks? It is recommended to set it to true. In \
                that case, ground truth mask will be downloaded before computations.
        &#34;&#34;&#34;

        self.benchmarkDir = benchmarkDir
        self.predictionType = predictionType
        self.usePredConfidence = usePredConfidence
        self.relionBinDir = os.path.abspath(os.path.expanduser(relionBinDir)) if relionBinDir else &#34;&#34;
        self.mpirun = mpirun
        self.relionSingularity = os.path.abspath(os.path.expanduser(relionSingularity)) if relionSingularity else None
        self.n_cpus = n_cpus
        self.wdir = wdir
        self.verbose = verbose
        self.use_gt_mask = use_gt_mask

    def reconstruct(self, starFname: str, outname: str, particlesDir: str, symmetry: str = &#34;c1&#34;,
                    cleanExisting: bool = True) -&gt; Tuple[np.ndarray, float]:
        &#34;&#34;&#34;
        Reconstruct a volume from the information contained in a starfile.
        Args:
            starFname: The starfile with the information to be reconstructed
            outname: The .mrc file where the reconstructed volume will be saved
            particlesDir (str): particlesDir
            symmetry: The point symmetry of the dataset.
            cleanExisting: True if an existing file should be removed
        Returns:
            Tuple[np.ndarray, float]:
        &#34;&#34;&#34;
        with tempfile.TemporaryDirectory() as tmpdir:
            exists = osp.isfile(outname)
            if exists and cleanExisting:
                os.unlink(outname)
                exists = False
            if not exists:
                cmd = []
                wdir = particlesDir if particlesDir else osp.dirname(starFname)
                if self.relionSingularity:
                    cmd += [self.relionSingularity, str(self.n_cpus)]
                    destination = osp.join(tmpdir, osp.basename(wdir))
                    shutil.copytree(wdir, destination)
                    baseStar = osp.basename(starFname)
                    shutil.copy(starFname, destination)
                    starFname = osp.join(destination, baseStar)
                    wdir = destination
                else:
                    if self.n_cpus &gt; 1:
                        cmd += self.mpirun.split() + [&#34;-np&#34;, str(self.n_cpus),
                                                      osp.join(self.relionBinDir, &#34;relion_reconstruct_mpi&#34;)]
                    else:
                        cmd += [osp.join(self.relionBinDir, &#34;relion_reconstruct&#34;)]

                with tempfile.NamedTemporaryFile(suffix=&#34;.mrc&#34;) as f:
                    cmd += [&#34;--i&#34;, starFname, &#34;--o&#34;, f.name, &#34;--ctf&#34;, &#34;--sym&#34;, symmetry.lower(), &#34;--pad&#34;, &#34;2.0&#34;]
                    if self.usePredConfidence:
                        data = starfile.read(starFname)
                        if RELION_PRED_POSE_CONFIDENCE_NAME in data[&#34;particles&#34;]:
                            cmd += [&#34;--fom_weighting&#34;]
                    if self.verbose:
                        print(&#34; &#34;.join(cmd))
                    subprocess.run(cmd, cwd=wdir, check=True, capture_output=not self.verbose)
                    f.seek(0)
                    shutil.copyfile(f.name, outname)
            else:
                print(f&#34;Reusing file {outname}&#34;)
            with mrcfile.open(outname) as f:
                data = f.data.copy()
                sampling_rate = float(f.voxel_size.x)
        return data, sampling_rate

    def computeMask(self, volFname: str, maskFname: str, lowpass_res: float = 15.0, volThr: float = 0.015,
                    mask_pix_exten: int = 3, mask_pix_soft: int = 4):
        &#34;&#34;&#34;
        Computes a mask for a volume and stores it in maskFname using relion_mask_create

        Args:
            starFname: The starfile with the information to be reconstructed
            maskFname: The .mrc file where the mask volume will be saved
            lowpass_res (float): Low pass filtering before applying any opperation, in Angstroms
            volThr (float): volume threshold to compute the mask
            mask_pix_exten (int): How many pixels the mask should be extended after thresholding
            mask_pix_soft (int): How many pixels the mask should be softened after extension
        Returns:
            Tuple[np.ndarray, float]:
        &#34;&#34;&#34;
        cmd = (f&#34;{osp.join(self.relionBinDir, &#39;relion_mask_create&#39;)}  --o {maskFname} &#34;
               f&#34;--i  {volFname} --ini_threshold  {volThr} &#34;
               f&#34;--extend_inimask  {mask_pix_exten} &#34;
               f&#34;--width_soft_edge {mask_pix_exten} mask_pix_soft {mask_pix_soft} &#34;
               f&#34;--lowpass  {lowpass_res} --j {self.n_cpus} &#34;)

        if self.verbose:
            print(&#34; &#34;.join(cmd))
        subprocess.run(cmd.split(), check=True, capture_output=not self.verbose)
        with mrcfile.open(maskFname) as f:
            return f.data.copy()

    def computeAvgMap(self, starFname0: str, starFname1: str, particlesDir: str,
                      outbasename: str, symmetry: str, cleanExisting: bool = True, mask: Optional[str] = None):
        &#34;&#34;&#34;
        Reconstruct each of the half-datasets starFname0 and starFname0 and averages the reconstruction to
        obtain the final average map
        Args:
            starFname0 (str): The filename with the predicted poses for the first half of the dataset
            starFname1 (str):
            particlesDir (str):
            outbasename (str):
            symmetry (str):
            cleanExisting (bool): True if an existing file should be removed
            maskFname (str): The Fname with a mask
        Returns:

        &#34;&#34;&#34;
        name0 = osp.join(self.wdir, outbasename + &#34;_0.mrc&#34;)
        data0, sr0 = self.reconstruct(starFname0, name0, particlesDir, symmetry=symmetry, cleanExisting=cleanExisting)

        name1 = osp.join(self.wdir, outbasename + &#34;_1.mrc&#34;)
        data1, sr1 = self.reconstruct(starFname1, name1, particlesDir, symmetry=symmetry, cleanExisting=cleanExisting)
        assert sr0 == sr1, &#34;Error, the sampling rate of the two datasets is different&#34;

        (corr, m_corr), resolt = compute_stats(name0, name1, maskOrFname=mask, samplingRate=sr0,
                                               resolution_threshold=0.143)

        resolt0143, m_resolt0143 = resolt[:2]

        _, resolt05 = compute_stats(name0, name1, maskOrFname=mask, samplingRate=sr0,
                                    resolution_threshold=0.5)
        resolt05, m_resolt05 = resolt05[:2]

        outvol = .5 * (data0 + data1)
        if not outbasename.endswith(&#34;.mrc&#34;):
            outbasename += &#34;.mrc&#34;
        mrcfile.write(osp.join(self.wdir, outbasename), outvol, voxel_size=sr0, overwrite=True)

        if self.use_gt_mask:
            corr = m_corr
            resolt0143 = m_resolt0143
            resolt05 = m_resolt05
        return outvol, sr0, corr, resolt0143, resolt05

    def preparePredStar(self, referStarFname: str, predStarFname: str, outname: str, symmetry: str):
        &#34;&#34;&#34;
        Transplants pose parameters not predicted by the model from the ground-truth pose data. Then compute
        angular errors comparing transplated poses with ground-truth poses

        Args:
            referStarFname (str): The file with the ground-truth poses
            predStarFname (str): The file with the predicted poses
            outname (str): The name for the transplated poses.
            symmetry (str): The point symmetry of the dataset.

        Returns:

        &#34;&#34;&#34;

        if self.predictionType == &#34;S2&#34;:
            predicted_keys = RELION_ANGLES_NAMES[:2].copy()
        elif self.predictionType == &#34;SO3&#34;:
            predicted_keys = RELION_ANGLES_NAMES.copy()
        elif self.predictionType == &#34;SO3xR2&#34;:
            predicted_keys = RELION_ANGLES_NAMES.copy() + RELION_SHIFTS_NAMES.copy()
        else:
            raise ValueError(f&#34;Error, predictionType option {self.predictionType} is not valid&#34;)
        if self.usePredConfidence:
            predicted_keys += [RELION_PRED_POSE_CONFIDENCE_NAME]

        referData = starfile.read(referStarFname)
        if RELION_PRED_POSE_CONFIDENCE_NAME not in referData[&#34;particles&#34;]:
            referData[&#34;particles&#34;][RELION_PRED_POSE_CONFIDENCE_NAME] = 1.
        predData = starfile.read(predStarFname)
        if RELION_PRED_POSE_CONFIDENCE_NAME not in predData[&#34;particles&#34;]:
            predData[&#34;particles&#34;][RELION_PRED_POSE_CONFIDENCE_NAME] = 1.

        referData[&#34;particles&#34;] = referData[&#34;particles&#34;].sort_values(by=RELION_IMAGE_FNAME).reset_index(drop=True)
        predData[&#34;particles&#34;] = predData[&#34;particles&#34;].sort_values(by=RELION_IMAGE_FNAME).reset_index(drop=True)
        assert referData[&#34;particles&#34;][RELION_IMAGE_FNAME].equals(predData[&#34;particles&#34;][RELION_IMAGE_FNAME]), \
            (f&#34;Error, there is a mismatch between the ids of the predicted {predStarFname} data and the benchmark&#34;
             f&#34; data {referStarFname}&#34;)

        predAngles = predData[&#34;particles&#34;][RELION_ANGLES_NAMES].values
        gtAngles = referData[&#34;particles&#34;][RELION_ANGLES_NAMES].values
        assert predAngles.shape[0] == gtAngles.shape[0], (&#34;Error, mismatch in the number of predicted particles and gt&#34;
                                                          f&#34;particles for {referStarFname} {predStarFname}&#34;)
        meanAngularError, wMeanAngularError, totalConf = computeAngularError(
            predAngles, gtAngles,
            confidence=referData[&#34;particles&#34;][RELION_ORI_POSE_CONFIDENCE_NAME].values,
            symmetry=symmetry)

        n_elems = len(referData[&#34;particles&#34;][RELION_SHIFTS_NAMES].values)
        shiftsRMSE = np.linalg.norm(predData[&#34;particles&#34;][RELION_SHIFTS_NAMES].values -
                                    referData[&#34;particles&#34;][RELION_SHIFTS_NAMES].values) / np.sqrt(n_elems)

        result = referData.copy()
        result[&#34;particles&#34;] = result[&#34;particles&#34;].copy()
        result[&#34;particles&#34;][predicted_keys] = predData[&#34;particles&#34;][predicted_keys]
        if outname is not None:
            starfile.write(result, outname)
        return result, meanAngularError, wMeanAngularError, shiftsRMSE, totalConf

    def runEvaluate(self, targetName, half0PredsFname, half1PredsFname, rm_prev_reconstructions, ignore_symmetry):

        with (tempfile.TemporaryDirectory() as tmpdir):
            if self.wdir is None:
                wdir = tmpdir
            else:
                wdir = self.wdir
                os.makedirs(wdir, exist_ok=True)

            os.makedirs(wdir, exist_ok=True)
            ps0 = ParticlesDataset(targetName, halfset=0, benchmarkDir=self.benchmarkDir)
            ps1 = ParticlesDataset(targetName, halfset=1, benchmarkDir=self.benchmarkDir)

            # GET MASK
            if self.use_gt_mask:
                print(&#34;Downloading mask&#34;)
                mask_fname = osp.join(wdir, &#34;mask.mrc&#34;)
                download_mask(targetName, mask_fname)
            else:
                mask_fname = None

            symmetry = ps0.symmetry if not ignore_symmetry else &#34;C1&#34;
            gt_map, gt_sampling, gt_cor, gt_resolt0143, gt_resolt05 = self.computeAvgMap(ps0.starFname, ps1.starFname,
                                                                                         particlesDir=ps0.datadir,
                                                                                         outbasename=&#34;gt&#34;,
                                                                                         symmetry=symmetry,
                                                                                         cleanExisting=False,
                                                                                         mask=mask_fname)
            prepStarFname0 = osp.join(tmpdir, &#34;prepStarFname0.star&#34;)
            _, meanAngularError0, wMeanAngularError0, shiftsRMSE0, totalConf0 = \
                self.preparePredStar(ps0.starFname, half0PredsFname, prepStarFname0, symmetry)
            prepStarFname1 = osp.join(tmpdir, &#34;prepStarFname1.star&#34;)
            _, meanAngularError1, wMeanAngularError1, shiftsRMSE1, totalConf1 = \
                self.preparePredStar(ps1.starFname, half1PredsFname, prepStarFname1, symmetry)

            meanAngularError = .5 * (meanAngularError0 + meanAngularError1)
            wMeanAngularError = (totalConf0 * wMeanAngularError0 + totalConf1 * wMeanAngularError1) / (
                    totalConf0 + totalConf1)
            shiftsRMSE = .5 * (shiftsRMSE0 + shiftsRMSE1)

            assert ps0.datadir == ps1.datadir
            pred_map, pred_sampling, pred_corr, pred_resolut, pred_resolt05 = self.computeAvgMap(
                prepStarFname0, prepStarFname1,
                particlesDir=ps0.datadir, outbasename=&#34;pred&#34;,
                symmetry=symmetry, cleanExisting=rm_prev_reconstructions, mask=mask_fname)

            if self.verbose:
                print(&#34;Computing statistics...&#34;)
            mapVsGT_cor, (mapVsGT_resolt, m_mapVsGT_resolt, *_) = compute_stats(gt_map, pred_map,
                                                                                samplingRate=gt_sampling,
                                                                                resolution_threshold=0.143,
                                                                                maskOrFname=mask_fname)
            _, (mapVsGT_resolt05, m_mapVsGT_resolt05, *_) = compute_stats(gt_map, pred_map,
                                                                          samplingRate=gt_sampling,
                                                                          resolution_threshold=0.5,
                                                                          maskOrFname=mask_fname)
            cor_diff = (gt_cor - mapVsGT_cor) #/ gt_cor

            res_diff05 = mapVsGT_resolt05 - gt_resolt05
            res_diff = mapVsGT_resolt - gt_resolt0143


            metrics = dict(meanAngularError=meanAngularError, wMeanAngularError=wMeanAngularError,
                           shiftsRMSE=shiftsRMSE,
                           GT_correlation=gt_cor,
                           GT_resolution0143=gt_resolt0143, GT_resolution05=gt_resolt05,
                           half2half_resolution=pred_resolut, half2half_resolution05=pred_resolt05,
                           half2half_correlation=pred_corr,
                           mapVsGT_correlaton_masked=mapVsGT_cor[1], mapVsGT_correlaton_unmasked=mapVsGT_cor[0],
                           mapVsGT_resolution=mapVsGT_resolt, mapVsGT_resolution05=mapVsGT_resolt05,
                           )

            with open(osp.join(self.wdir, &#34;metrics.json&#34;), &#34;w&#34;) as f:
                json.dump(metrics, f)

            report_str = f&#34;&#34;&#34;
&gt; EVALUATION for target:                  {targetName}
GT_correlation:                           {gt_cor}
GT_resolution (Å) (th=0.143, 0.5):        {gt_resolt0143}  {gt_resolt05}
&gt; RESULTS
#Predictions
mean_angular_error (°):                   {meanAngularError} 
w_mean_angular_error (°):                 {wMeanAngularError} 
shifts_RMSE (Å):                          {shiftsRMSE}
#Reconstruction
half2half_correlation:                    {pred_corr}
half2half_resolution (Å) (th=0.143, 0.5): {pred_resolut}  {pred_resolt05}
mapVsGT_correlaton (masked, unmasked):    {&#34;  &#34;.join(reversed([str(x) for x in mapVsGT_cor]))}
mapVsGT_resolution (Å) (th=0.143, 0.5)    {mapVsGT_resolt}  {mapVsGT_resolt05}
#Reconstruction differences
cor_diff (%) (masked, unmasked):          {&#34;  &#34;.join(reversed([str(x * 100) for x in cor_diff]))}
res_diff (Å) th=0.143, 0.5):              {res_diff}  {res_diff05}
            &#34;&#34;&#34;

            if self.verbose:
                print(report_str)
            return metrics


def evaluate(targetName: str, half0PredsFname: str, half1PredsFname: str,
             predictionType: Literal[&#34;S2&#34;, &#34;SO3&#34;, &#34;SO3xR2&#34;], usePredConfidence: bool = True,
             benchmarkDir: str = defaultBenchmarkDir, relionBinDir: Optional[str] = relionBinDir,
             mpirun: Optional[str] = mpirunCmd, relionSingularity: Optional[str] = relionSingularity,
             rm_prev_reconstructions: bool = True,
             ignore_symmetry: bool = False, use_gt_mask:bool=True,
             n_cpus: int = 2, outdir: Optional[str] = None) -&gt; Dict[str, float]:
    &#34;&#34;&#34;

    Args:
        targetName (str): The name of the target to use. It is also the basename of \
            the directory where the data is.
        half0PredsFname (str): The starfile for the half0 of the data with predicted poses
        half1PredsFname (str): The starfile for the half1 of the data with predicted poses
        predictionType (Literal[S2, SO3, SO3xR2]): The type of the predicted pose. S2 if only \
            the first two euler angles were predicted (cones). SO3 if all the 3 euler angles were predicted. \
            SO3xR2 if both the euler angles and the particle shifts (translations) were predicted. Depending on the
            type of prediction, the ground-truth values will be used to fill in the missing information
        usePredConfidence (bool): If true, particles are weighted by the predicted confidence at reconstruction time
        benchmarkDir (str): The root directory where the datasets are downloaded.
        relionBinDir (Optional[str]): The Relion bin directory. If not provided, it is read from configs/defaultRelionConfig.yaml
        mpirun (Optional[str]): The mpriun command. Required inf n_cpus &gt;1. If not provided, it is read from configs/defaultRelionConfig.yaml
        relionSingularity (Optional[str]): A built singularity image from relionSingularity.def that let you install and run relion easily
        rm_prev_reconstructions (bool): If True, the reconstructions from predicted angles stored in outdir will \
        be recomputed
        ignore_symmetry (bool): If True, reconstruct ignoring symmetry
        use_gt_mask (bool): If True, computations are performed using the ground truth mask that will be downloaded.
        n_cpus (int): The number of cpus used in the calculations
        outdir (Optional[str]): The directory where computations will be stored. Used as cache for the GT \
         computations. If None, a temporary directory will be used instead

    Returns:
            Dict[str,float]: A dictionary with the computed metrics

    &#34;&#34;&#34;

    half0PredsFname = osp.expanduser(half0PredsFname)
    assert osp.exists(half0PredsFname), f&#34;Error half0PredsFname: {half0PredsFname} not found!&#34;

    half1PredsFname = osp.expanduser(half1PredsFname)
    assert osp.exists(half1PredsFname), f&#34;Error half1PredsFname: {half1PredsFname} not found!&#34;

    with tempfile.TemporaryDirectory() as tmpdir:
        if outdir is None:
            outdir = tmpdir
        evaluator = Evaluator(predictionType, usePredConfidence=usePredConfidence, benchmarkDir=benchmarkDir,
                              relionBinDir=relionBinDir, mpirun=mpirun, relionSingularity=relionSingularity,
                              n_cpus=n_cpus, wdir=outdir,
                              use_gt_mask=use_gt_mask)
        return evaluator.runEvaluate(targetName, half0PredsFname, half1PredsFname,
                                     rm_prev_reconstructions, ignore_symmetry)


def _test():
    targetName = &#34;TEST&#34;
    benchmarkDir = &#34;/tmp/cryoSupervisedDataset&#34;
    half0PredsFname = &#34;/tmp/results_half0.star&#34;
    half1PredsFname = &#34;/tmp/results_half1.star&#34;
    evaluate(targetName, half0PredsFname, half1PredsFname, predictionType=&#34;SO3&#34;, usePredConfidence=True,
             benchmarkDir=benchmarkDir, n_cpus=1, outdir=&#34;/tmp/pruebaReconstruct&#34;)


if __name__ == &#34;__main__&#34;:
    # _test()
    from argParseFromDoc import parse_function_and_call
    parse_function_and_call(evaluate)

&#34;&#34;&#34;
--targetName TEST --half0PredsFname /tmp/results_half0.star --half1PredsFname /tmp/results.star --predictionType SO3
&#34;&#34;&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="cesped.evaluateEntry.evaluate"><code class="name flex">
<span>def <span class="ident">evaluate</span></span>(<span>targetName: str, half0PredsFname: str, half1PredsFname: str, predictionType: Literal['S2', 'SO3', 'SO3xR2'], usePredConfidence: bool = True, benchmarkDir: str = '/home/sanchezg/tmp/cryoSupervisedDataset', relionBinDir: Optional[str] = '/home/sanchezg/app/scipion/software/em/relion/bin', mpirun: Optional[str] = 'mpirun', relionSingularity: Optional[str] = None, rm_prev_reconstructions: bool = True, ignore_symmetry: bool = False, use_gt_mask: bool = True, n_cpus: int = 2, outdir: Optional[str] = None) ‑> Dict[str, float]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>targetName</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the target to use. It is also the basename of
the directory where the data is.</dd>
<dt><strong><code>half0PredsFname</code></strong> :&ensp;<code>str</code></dt>
<dd>The starfile for the half0 of the data with predicted poses</dd>
<dt><strong><code>half1PredsFname</code></strong> :&ensp;<code>str</code></dt>
<dd>The starfile for the half1 of the data with predicted poses</dd>
<dt><strong><code>predictionType</code></strong> :&ensp;<code>Literal[S2, SO3, SO3xR2]</code></dt>
<dd>The type of the predicted pose. S2 if only
the first two euler angles were predicted (cones). SO3 if all the 3 euler angles were predicted.
SO3xR2 if both the euler angles and the particle shifts (translations) were predicted. Depending on the
type of prediction, the ground-truth values will be used to fill in the missing information</dd>
<dt><strong><code>usePredConfidence</code></strong> :&ensp;<code>bool</code></dt>
<dd>If true, particles are weighted by the predicted confidence at reconstruction time</dd>
<dt><strong><code>benchmarkDir</code></strong> :&ensp;<code>str</code></dt>
<dd>The root directory where the datasets are downloaded.</dd>
<dt><strong><code>relionBinDir</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The Relion bin directory. If not provided, it is read from configs/defaultRelionConfig.yaml</dd>
<dt><strong><code>mpirun</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The mpriun command. Required inf n_cpus &gt;1. If not provided, it is read from configs/defaultRelionConfig.yaml</dd>
<dt><strong><code>relionSingularity</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>A built singularity image from relionSingularity.def that let you install and run relion easily</dd>
<dt><strong><code>rm_prev_reconstructions</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, the reconstructions from predicted angles stored in outdir will
be recomputed</dd>
<dt><strong><code>ignore_symmetry</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, reconstruct ignoring symmetry</dd>
<dt><strong><code>use_gt_mask</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, computations are performed using the ground truth mask that will be downloaded.</dd>
<dt><strong><code>n_cpus</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of cpus used in the calculations</dd>
<dt><strong><code>outdir</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The directory where computations will be stored. Used as cache for the GT
computations. If None, a temporary directory will be used instead</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[str,float]</code></dt>
<dd>A dictionary with the computed metrics</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate(targetName: str, half0PredsFname: str, half1PredsFname: str,
             predictionType: Literal[&#34;S2&#34;, &#34;SO3&#34;, &#34;SO3xR2&#34;], usePredConfidence: bool = True,
             benchmarkDir: str = defaultBenchmarkDir, relionBinDir: Optional[str] = relionBinDir,
             mpirun: Optional[str] = mpirunCmd, relionSingularity: Optional[str] = relionSingularity,
             rm_prev_reconstructions: bool = True,
             ignore_symmetry: bool = False, use_gt_mask:bool=True,
             n_cpus: int = 2, outdir: Optional[str] = None) -&gt; Dict[str, float]:
    &#34;&#34;&#34;

    Args:
        targetName (str): The name of the target to use. It is also the basename of \
            the directory where the data is.
        half0PredsFname (str): The starfile for the half0 of the data with predicted poses
        half1PredsFname (str): The starfile for the half1 of the data with predicted poses
        predictionType (Literal[S2, SO3, SO3xR2]): The type of the predicted pose. S2 if only \
            the first two euler angles were predicted (cones). SO3 if all the 3 euler angles were predicted. \
            SO3xR2 if both the euler angles and the particle shifts (translations) were predicted. Depending on the
            type of prediction, the ground-truth values will be used to fill in the missing information
        usePredConfidence (bool): If true, particles are weighted by the predicted confidence at reconstruction time
        benchmarkDir (str): The root directory where the datasets are downloaded.
        relionBinDir (Optional[str]): The Relion bin directory. If not provided, it is read from configs/defaultRelionConfig.yaml
        mpirun (Optional[str]): The mpriun command. Required inf n_cpus &gt;1. If not provided, it is read from configs/defaultRelionConfig.yaml
        relionSingularity (Optional[str]): A built singularity image from relionSingularity.def that let you install and run relion easily
        rm_prev_reconstructions (bool): If True, the reconstructions from predicted angles stored in outdir will \
        be recomputed
        ignore_symmetry (bool): If True, reconstruct ignoring symmetry
        use_gt_mask (bool): If True, computations are performed using the ground truth mask that will be downloaded.
        n_cpus (int): The number of cpus used in the calculations
        outdir (Optional[str]): The directory where computations will be stored. Used as cache for the GT \
         computations. If None, a temporary directory will be used instead

    Returns:
            Dict[str,float]: A dictionary with the computed metrics

    &#34;&#34;&#34;

    half0PredsFname = osp.expanduser(half0PredsFname)
    assert osp.exists(half0PredsFname), f&#34;Error half0PredsFname: {half0PredsFname} not found!&#34;

    half1PredsFname = osp.expanduser(half1PredsFname)
    assert osp.exists(half1PredsFname), f&#34;Error half1PredsFname: {half1PredsFname} not found!&#34;

    with tempfile.TemporaryDirectory() as tmpdir:
        if outdir is None:
            outdir = tmpdir
        evaluator = Evaluator(predictionType, usePredConfidence=usePredConfidence, benchmarkDir=benchmarkDir,
                              relionBinDir=relionBinDir, mpirun=mpirun, relionSingularity=relionSingularity,
                              n_cpus=n_cpus, wdir=outdir,
                              use_gt_mask=use_gt_mask)
        return evaluator.runEvaluate(targetName, half0PredsFname, half1PredsFname,
                                     rm_prev_reconstructions, ignore_symmetry)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cesped.evaluateEntry.Evaluator"><code class="flex name class">
<span>class <span class="ident">Evaluator</span></span>
<span>(</span><span>predictionType: Literal['S2', 'SO3', 'SO3xR2'], usePredConfidence: bool = True, benchmarkDir: Union[os.PathLike, str] = '/home/sanchezg/tmp/cryoSupervisedDataset', relionBinDir: Optional[str] = '/home/sanchezg/app/scipion/software/em/relion/bin', mpirun: Optional[str] = 'mpirun', relionSingularity: Optional[str] = None, n_cpus=1, wdir=None, verbose=True, use_gt_mask=True)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>predictionType</code></strong> :&ensp;<code>Literal[S2, SO3, SO3xR2]</code></dt>
<dd>The type of the predicted pose. S2 if only
the first two euler angles were predicted (cones). SO3 if all the 3 euler angles were predicted.
SO3xR2 if both the euler angles and the particle shifts (translations) were predicted. Depending on the
type of prediction, the ground-truth values will be used to fill in the missing information
usePredConfidence:</dd>
<dt><strong><code>benchmarkDir</code></strong> :&ensp;<code>str</code></dt>
<dd>The root directory where the datasets are downloaded.</dd>
<dt><strong><code>relionBinDir</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The Relion bin directory. If not provided, it is read from configs/defaultRelionConfig.yaml</dd>
<dt><strong><code>mpirun</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The mpriun command. Required inf n_cpus &gt;1. If not provided, it is read from configs/defaultRelionConfig.yaml</dd>
<dt><strong><code>relionSingularity</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>A built singularity image from relionSingularity.def that let you install and run relion easily</dd>
<dt><strong><code>n_cpus</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of cpus used in the calculations</dd>
<dt><strong><code>wdir</code></strong> :&ensp;<code>str</code></dt>
<dd>The directory where intermediate results will be saved. It acts as a cache as well</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>Print to stdout? Set it to true if using via command line</dd>
<dt><strong><code>use_gt_mask</code></strong> :&ensp;<code>bool</code></dt>
<dd>Should computations use ground-truth masks? It is recommended to set it to true. In
that case, ground truth mask will be downloaded before computations.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Evaluator():

    def __init__(self, predictionType: Literal[&#34;S2&#34;, &#34;SO3&#34;, &#34;SO3xR2&#34;], usePredConfidence: bool = True,
                 benchmarkDir: Union[str, os.PathLike] = defaultBenchmarkDir,
                 relionBinDir:Optional[str]=relionBinDir, mpirun:Optional[str]=mpirunCmd,
                 relionSingularity:Optional[str]=relionSingularity,
                 n_cpus=1, wdir=None, verbose=True, use_gt_mask=True):
        &#34;&#34;&#34;

        Args:
            predictionType (Literal[S2, SO3, SO3xR2]): The type of the predicted pose. S2 if only \
                the first two euler angles were predicted (cones). SO3 if all the 3 euler angles were predicted. \
                SO3xR2 if both the euler angles and the particle shifts (translations) were predicted. Depending on the
                type of prediction, the ground-truth values will be used to fill in the missing information            usePredConfidence:
            benchmarkDir (str): The root directory where the datasets are downloaded.
            relionBinDir (Optional[str]): The Relion bin directory. If not provided, it is read from configs/defaultRelionConfig.yaml
            mpirun (Optional[str]): The mpriun command. Required inf n_cpus &gt;1. If not provided, it is read from configs/defaultRelionConfig.yaml
            relionSingularity (Optional[str]): A built singularity image from relionSingularity.def that let you install and run relion easily
            n_cpus (int): The number of cpus used in the calculations
            wdir (str): The directory where intermediate results will be saved. It acts as a cache as well
            verbose (bool): Print to stdout? Set it to true if using via command line
            use_gt_mask (bool): Should computations use ground-truth masks? It is recommended to set it to true. In \
                that case, ground truth mask will be downloaded before computations.
        &#34;&#34;&#34;

        self.benchmarkDir = benchmarkDir
        self.predictionType = predictionType
        self.usePredConfidence = usePredConfidence
        self.relionBinDir = os.path.abspath(os.path.expanduser(relionBinDir)) if relionBinDir else &#34;&#34;
        self.mpirun = mpirun
        self.relionSingularity = os.path.abspath(os.path.expanduser(relionSingularity)) if relionSingularity else None
        self.n_cpus = n_cpus
        self.wdir = wdir
        self.verbose = verbose
        self.use_gt_mask = use_gt_mask

    def reconstruct(self, starFname: str, outname: str, particlesDir: str, symmetry: str = &#34;c1&#34;,
                    cleanExisting: bool = True) -&gt; Tuple[np.ndarray, float]:
        &#34;&#34;&#34;
        Reconstruct a volume from the information contained in a starfile.
        Args:
            starFname: The starfile with the information to be reconstructed
            outname: The .mrc file where the reconstructed volume will be saved
            particlesDir (str): particlesDir
            symmetry: The point symmetry of the dataset.
            cleanExisting: True if an existing file should be removed
        Returns:
            Tuple[np.ndarray, float]:
        &#34;&#34;&#34;
        with tempfile.TemporaryDirectory() as tmpdir:
            exists = osp.isfile(outname)
            if exists and cleanExisting:
                os.unlink(outname)
                exists = False
            if not exists:
                cmd = []
                wdir = particlesDir if particlesDir else osp.dirname(starFname)
                if self.relionSingularity:
                    cmd += [self.relionSingularity, str(self.n_cpus)]
                    destination = osp.join(tmpdir, osp.basename(wdir))
                    shutil.copytree(wdir, destination)
                    baseStar = osp.basename(starFname)
                    shutil.copy(starFname, destination)
                    starFname = osp.join(destination, baseStar)
                    wdir = destination
                else:
                    if self.n_cpus &gt; 1:
                        cmd += self.mpirun.split() + [&#34;-np&#34;, str(self.n_cpus),
                                                      osp.join(self.relionBinDir, &#34;relion_reconstruct_mpi&#34;)]
                    else:
                        cmd += [osp.join(self.relionBinDir, &#34;relion_reconstruct&#34;)]

                with tempfile.NamedTemporaryFile(suffix=&#34;.mrc&#34;) as f:
                    cmd += [&#34;--i&#34;, starFname, &#34;--o&#34;, f.name, &#34;--ctf&#34;, &#34;--sym&#34;, symmetry.lower(), &#34;--pad&#34;, &#34;2.0&#34;]
                    if self.usePredConfidence:
                        data = starfile.read(starFname)
                        if RELION_PRED_POSE_CONFIDENCE_NAME in data[&#34;particles&#34;]:
                            cmd += [&#34;--fom_weighting&#34;]
                    if self.verbose:
                        print(&#34; &#34;.join(cmd))
                    subprocess.run(cmd, cwd=wdir, check=True, capture_output=not self.verbose)
                    f.seek(0)
                    shutil.copyfile(f.name, outname)
            else:
                print(f&#34;Reusing file {outname}&#34;)
            with mrcfile.open(outname) as f:
                data = f.data.copy()
                sampling_rate = float(f.voxel_size.x)
        return data, sampling_rate

    def computeMask(self, volFname: str, maskFname: str, lowpass_res: float = 15.0, volThr: float = 0.015,
                    mask_pix_exten: int = 3, mask_pix_soft: int = 4):
        &#34;&#34;&#34;
        Computes a mask for a volume and stores it in maskFname using relion_mask_create

        Args:
            starFname: The starfile with the information to be reconstructed
            maskFname: The .mrc file where the mask volume will be saved
            lowpass_res (float): Low pass filtering before applying any opperation, in Angstroms
            volThr (float): volume threshold to compute the mask
            mask_pix_exten (int): How many pixels the mask should be extended after thresholding
            mask_pix_soft (int): How many pixels the mask should be softened after extension
        Returns:
            Tuple[np.ndarray, float]:
        &#34;&#34;&#34;
        cmd = (f&#34;{osp.join(self.relionBinDir, &#39;relion_mask_create&#39;)}  --o {maskFname} &#34;
               f&#34;--i  {volFname} --ini_threshold  {volThr} &#34;
               f&#34;--extend_inimask  {mask_pix_exten} &#34;
               f&#34;--width_soft_edge {mask_pix_exten} mask_pix_soft {mask_pix_soft} &#34;
               f&#34;--lowpass  {lowpass_res} --j {self.n_cpus} &#34;)

        if self.verbose:
            print(&#34; &#34;.join(cmd))
        subprocess.run(cmd.split(), check=True, capture_output=not self.verbose)
        with mrcfile.open(maskFname) as f:
            return f.data.copy()

    def computeAvgMap(self, starFname0: str, starFname1: str, particlesDir: str,
                      outbasename: str, symmetry: str, cleanExisting: bool = True, mask: Optional[str] = None):
        &#34;&#34;&#34;
        Reconstruct each of the half-datasets starFname0 and starFname0 and averages the reconstruction to
        obtain the final average map
        Args:
            starFname0 (str): The filename with the predicted poses for the first half of the dataset
            starFname1 (str):
            particlesDir (str):
            outbasename (str):
            symmetry (str):
            cleanExisting (bool): True if an existing file should be removed
            maskFname (str): The Fname with a mask
        Returns:

        &#34;&#34;&#34;
        name0 = osp.join(self.wdir, outbasename + &#34;_0.mrc&#34;)
        data0, sr0 = self.reconstruct(starFname0, name0, particlesDir, symmetry=symmetry, cleanExisting=cleanExisting)

        name1 = osp.join(self.wdir, outbasename + &#34;_1.mrc&#34;)
        data1, sr1 = self.reconstruct(starFname1, name1, particlesDir, symmetry=symmetry, cleanExisting=cleanExisting)
        assert sr0 == sr1, &#34;Error, the sampling rate of the two datasets is different&#34;

        (corr, m_corr), resolt = compute_stats(name0, name1, maskOrFname=mask, samplingRate=sr0,
                                               resolution_threshold=0.143)

        resolt0143, m_resolt0143 = resolt[:2]

        _, resolt05 = compute_stats(name0, name1, maskOrFname=mask, samplingRate=sr0,
                                    resolution_threshold=0.5)
        resolt05, m_resolt05 = resolt05[:2]

        outvol = .5 * (data0 + data1)
        if not outbasename.endswith(&#34;.mrc&#34;):
            outbasename += &#34;.mrc&#34;
        mrcfile.write(osp.join(self.wdir, outbasename), outvol, voxel_size=sr0, overwrite=True)

        if self.use_gt_mask:
            corr = m_corr
            resolt0143 = m_resolt0143
            resolt05 = m_resolt05
        return outvol, sr0, corr, resolt0143, resolt05

    def preparePredStar(self, referStarFname: str, predStarFname: str, outname: str, symmetry: str):
        &#34;&#34;&#34;
        Transplants pose parameters not predicted by the model from the ground-truth pose data. Then compute
        angular errors comparing transplated poses with ground-truth poses

        Args:
            referStarFname (str): The file with the ground-truth poses
            predStarFname (str): The file with the predicted poses
            outname (str): The name for the transplated poses.
            symmetry (str): The point symmetry of the dataset.

        Returns:

        &#34;&#34;&#34;

        if self.predictionType == &#34;S2&#34;:
            predicted_keys = RELION_ANGLES_NAMES[:2].copy()
        elif self.predictionType == &#34;SO3&#34;:
            predicted_keys = RELION_ANGLES_NAMES.copy()
        elif self.predictionType == &#34;SO3xR2&#34;:
            predicted_keys = RELION_ANGLES_NAMES.copy() + RELION_SHIFTS_NAMES.copy()
        else:
            raise ValueError(f&#34;Error, predictionType option {self.predictionType} is not valid&#34;)
        if self.usePredConfidence:
            predicted_keys += [RELION_PRED_POSE_CONFIDENCE_NAME]

        referData = starfile.read(referStarFname)
        if RELION_PRED_POSE_CONFIDENCE_NAME not in referData[&#34;particles&#34;]:
            referData[&#34;particles&#34;][RELION_PRED_POSE_CONFIDENCE_NAME] = 1.
        predData = starfile.read(predStarFname)
        if RELION_PRED_POSE_CONFIDENCE_NAME not in predData[&#34;particles&#34;]:
            predData[&#34;particles&#34;][RELION_PRED_POSE_CONFIDENCE_NAME] = 1.

        referData[&#34;particles&#34;] = referData[&#34;particles&#34;].sort_values(by=RELION_IMAGE_FNAME).reset_index(drop=True)
        predData[&#34;particles&#34;] = predData[&#34;particles&#34;].sort_values(by=RELION_IMAGE_FNAME).reset_index(drop=True)
        assert referData[&#34;particles&#34;][RELION_IMAGE_FNAME].equals(predData[&#34;particles&#34;][RELION_IMAGE_FNAME]), \
            (f&#34;Error, there is a mismatch between the ids of the predicted {predStarFname} data and the benchmark&#34;
             f&#34; data {referStarFname}&#34;)

        predAngles = predData[&#34;particles&#34;][RELION_ANGLES_NAMES].values
        gtAngles = referData[&#34;particles&#34;][RELION_ANGLES_NAMES].values
        assert predAngles.shape[0] == gtAngles.shape[0], (&#34;Error, mismatch in the number of predicted particles and gt&#34;
                                                          f&#34;particles for {referStarFname} {predStarFname}&#34;)
        meanAngularError, wMeanAngularError, totalConf = computeAngularError(
            predAngles, gtAngles,
            confidence=referData[&#34;particles&#34;][RELION_ORI_POSE_CONFIDENCE_NAME].values,
            symmetry=symmetry)

        n_elems = len(referData[&#34;particles&#34;][RELION_SHIFTS_NAMES].values)
        shiftsRMSE = np.linalg.norm(predData[&#34;particles&#34;][RELION_SHIFTS_NAMES].values -
                                    referData[&#34;particles&#34;][RELION_SHIFTS_NAMES].values) / np.sqrt(n_elems)

        result = referData.copy()
        result[&#34;particles&#34;] = result[&#34;particles&#34;].copy()
        result[&#34;particles&#34;][predicted_keys] = predData[&#34;particles&#34;][predicted_keys]
        if outname is not None:
            starfile.write(result, outname)
        return result, meanAngularError, wMeanAngularError, shiftsRMSE, totalConf

    def runEvaluate(self, targetName, half0PredsFname, half1PredsFname, rm_prev_reconstructions, ignore_symmetry):

        with (tempfile.TemporaryDirectory() as tmpdir):
            if self.wdir is None:
                wdir = tmpdir
            else:
                wdir = self.wdir
                os.makedirs(wdir, exist_ok=True)

            os.makedirs(wdir, exist_ok=True)
            ps0 = ParticlesDataset(targetName, halfset=0, benchmarkDir=self.benchmarkDir)
            ps1 = ParticlesDataset(targetName, halfset=1, benchmarkDir=self.benchmarkDir)

            # GET MASK
            if self.use_gt_mask:
                print(&#34;Downloading mask&#34;)
                mask_fname = osp.join(wdir, &#34;mask.mrc&#34;)
                download_mask(targetName, mask_fname)
            else:
                mask_fname = None

            symmetry = ps0.symmetry if not ignore_symmetry else &#34;C1&#34;
            gt_map, gt_sampling, gt_cor, gt_resolt0143, gt_resolt05 = self.computeAvgMap(ps0.starFname, ps1.starFname,
                                                                                         particlesDir=ps0.datadir,
                                                                                         outbasename=&#34;gt&#34;,
                                                                                         symmetry=symmetry,
                                                                                         cleanExisting=False,
                                                                                         mask=mask_fname)
            prepStarFname0 = osp.join(tmpdir, &#34;prepStarFname0.star&#34;)
            _, meanAngularError0, wMeanAngularError0, shiftsRMSE0, totalConf0 = \
                self.preparePredStar(ps0.starFname, half0PredsFname, prepStarFname0, symmetry)
            prepStarFname1 = osp.join(tmpdir, &#34;prepStarFname1.star&#34;)
            _, meanAngularError1, wMeanAngularError1, shiftsRMSE1, totalConf1 = \
                self.preparePredStar(ps1.starFname, half1PredsFname, prepStarFname1, symmetry)

            meanAngularError = .5 * (meanAngularError0 + meanAngularError1)
            wMeanAngularError = (totalConf0 * wMeanAngularError0 + totalConf1 * wMeanAngularError1) / (
                    totalConf0 + totalConf1)
            shiftsRMSE = .5 * (shiftsRMSE0 + shiftsRMSE1)

            assert ps0.datadir == ps1.datadir
            pred_map, pred_sampling, pred_corr, pred_resolut, pred_resolt05 = self.computeAvgMap(
                prepStarFname0, prepStarFname1,
                particlesDir=ps0.datadir, outbasename=&#34;pred&#34;,
                symmetry=symmetry, cleanExisting=rm_prev_reconstructions, mask=mask_fname)

            if self.verbose:
                print(&#34;Computing statistics...&#34;)
            mapVsGT_cor, (mapVsGT_resolt, m_mapVsGT_resolt, *_) = compute_stats(gt_map, pred_map,
                                                                                samplingRate=gt_sampling,
                                                                                resolution_threshold=0.143,
                                                                                maskOrFname=mask_fname)
            _, (mapVsGT_resolt05, m_mapVsGT_resolt05, *_) = compute_stats(gt_map, pred_map,
                                                                          samplingRate=gt_sampling,
                                                                          resolution_threshold=0.5,
                                                                          maskOrFname=mask_fname)
            cor_diff = (gt_cor - mapVsGT_cor) #/ gt_cor

            res_diff05 = mapVsGT_resolt05 - gt_resolt05
            res_diff = mapVsGT_resolt - gt_resolt0143


            metrics = dict(meanAngularError=meanAngularError, wMeanAngularError=wMeanAngularError,
                           shiftsRMSE=shiftsRMSE,
                           GT_correlation=gt_cor,
                           GT_resolution0143=gt_resolt0143, GT_resolution05=gt_resolt05,
                           half2half_resolution=pred_resolut, half2half_resolution05=pred_resolt05,
                           half2half_correlation=pred_corr,
                           mapVsGT_correlaton_masked=mapVsGT_cor[1], mapVsGT_correlaton_unmasked=mapVsGT_cor[0],
                           mapVsGT_resolution=mapVsGT_resolt, mapVsGT_resolution05=mapVsGT_resolt05,
                           )

            with open(osp.join(self.wdir, &#34;metrics.json&#34;), &#34;w&#34;) as f:
                json.dump(metrics, f)

            report_str = f&#34;&#34;&#34;
&gt; EVALUATION for target:                  {targetName}
GT_correlation:                           {gt_cor}
GT_resolution (Å) (th=0.143, 0.5):        {gt_resolt0143}  {gt_resolt05}
&gt; RESULTS
#Predictions
mean_angular_error (°):                   {meanAngularError} 
w_mean_angular_error (°):                 {wMeanAngularError} 
shifts_RMSE (Å):                          {shiftsRMSE}
#Reconstruction
half2half_correlation:                    {pred_corr}
half2half_resolution (Å) (th=0.143, 0.5): {pred_resolut}  {pred_resolt05}
mapVsGT_correlaton (masked, unmasked):    {&#34;  &#34;.join(reversed([str(x) for x in mapVsGT_cor]))}
mapVsGT_resolution (Å) (th=0.143, 0.5)    {mapVsGT_resolt}  {mapVsGT_resolt05}
#Reconstruction differences
cor_diff (%) (masked, unmasked):          {&#34;  &#34;.join(reversed([str(x * 100) for x in cor_diff]))}
res_diff (Å) th=0.143, 0.5):              {res_diff}  {res_diff05}
            &#34;&#34;&#34;

            if self.verbose:
                print(report_str)
            return metrics</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="cesped.evaluateEntry.Evaluator.computeAvgMap"><code class="name flex">
<span>def <span class="ident">computeAvgMap</span></span>(<span>self, starFname0: str, starFname1: str, particlesDir: str, outbasename: str, symmetry: str, cleanExisting: bool = True, mask: Optional[str] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Reconstruct each of the half-datasets starFname0 and starFname0 and averages the reconstruction to
obtain the final average map</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>starFname0</code></strong> :&ensp;<code>str</code></dt>
<dd>The filename with the predicted poses for the first half of the dataset</dd>
<dt>starFname1 (str):</dt>
<dt>particlesDir (str):</dt>
<dt>outbasename (str):</dt>
<dt>symmetry (str):</dt>
<dt><strong><code>cleanExisting</code></strong> :&ensp;<code>bool</code></dt>
<dd>True if an existing file should be removed</dd>
<dt><strong><code>maskFname</code></strong> :&ensp;<code>str</code></dt>
<dd>The Fname with a mask</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def computeAvgMap(self, starFname0: str, starFname1: str, particlesDir: str,
                  outbasename: str, symmetry: str, cleanExisting: bool = True, mask: Optional[str] = None):
    &#34;&#34;&#34;
    Reconstruct each of the half-datasets starFname0 and starFname0 and averages the reconstruction to
    obtain the final average map
    Args:
        starFname0 (str): The filename with the predicted poses for the first half of the dataset
        starFname1 (str):
        particlesDir (str):
        outbasename (str):
        symmetry (str):
        cleanExisting (bool): True if an existing file should be removed
        maskFname (str): The Fname with a mask
    Returns:

    &#34;&#34;&#34;
    name0 = osp.join(self.wdir, outbasename + &#34;_0.mrc&#34;)
    data0, sr0 = self.reconstruct(starFname0, name0, particlesDir, symmetry=symmetry, cleanExisting=cleanExisting)

    name1 = osp.join(self.wdir, outbasename + &#34;_1.mrc&#34;)
    data1, sr1 = self.reconstruct(starFname1, name1, particlesDir, symmetry=symmetry, cleanExisting=cleanExisting)
    assert sr0 == sr1, &#34;Error, the sampling rate of the two datasets is different&#34;

    (corr, m_corr), resolt = compute_stats(name0, name1, maskOrFname=mask, samplingRate=sr0,
                                           resolution_threshold=0.143)

    resolt0143, m_resolt0143 = resolt[:2]

    _, resolt05 = compute_stats(name0, name1, maskOrFname=mask, samplingRate=sr0,
                                resolution_threshold=0.5)
    resolt05, m_resolt05 = resolt05[:2]

    outvol = .5 * (data0 + data1)
    if not outbasename.endswith(&#34;.mrc&#34;):
        outbasename += &#34;.mrc&#34;
    mrcfile.write(osp.join(self.wdir, outbasename), outvol, voxel_size=sr0, overwrite=True)

    if self.use_gt_mask:
        corr = m_corr
        resolt0143 = m_resolt0143
        resolt05 = m_resolt05
    return outvol, sr0, corr, resolt0143, resolt05</code></pre>
</details>
</dd>
<dt id="cesped.evaluateEntry.Evaluator.computeMask"><code class="name flex">
<span>def <span class="ident">computeMask</span></span>(<span>self, volFname: str, maskFname: str, lowpass_res: float = 15.0, volThr: float = 0.015, mask_pix_exten: int = 3, mask_pix_soft: int = 4)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes a mask for a volume and stores it in maskFname using relion_mask_create</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>starFname</code></strong></dt>
<dd>The starfile with the information to be reconstructed</dd>
<dt><strong><code>maskFname</code></strong></dt>
<dd>The .mrc file where the mask volume will be saved</dd>
<dt><strong><code>lowpass_res</code></strong> :&ensp;<code>float</code></dt>
<dd>Low pass filtering before applying any opperation, in Angstroms</dd>
<dt><strong><code>volThr</code></strong> :&ensp;<code>float</code></dt>
<dd>volume threshold to compute the mask</dd>
<dt><strong><code>mask_pix_exten</code></strong> :&ensp;<code>int</code></dt>
<dd>How many pixels the mask should be extended after thresholding</dd>
<dt><strong><code>mask_pix_soft</code></strong> :&ensp;<code>int</code></dt>
<dd>How many pixels the mask should be softened after extension</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Tuple[np.ndarray, float]:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def computeMask(self, volFname: str, maskFname: str, lowpass_res: float = 15.0, volThr: float = 0.015,
                mask_pix_exten: int = 3, mask_pix_soft: int = 4):
    &#34;&#34;&#34;
    Computes a mask for a volume and stores it in maskFname using relion_mask_create

    Args:
        starFname: The starfile with the information to be reconstructed
        maskFname: The .mrc file where the mask volume will be saved
        lowpass_res (float): Low pass filtering before applying any opperation, in Angstroms
        volThr (float): volume threshold to compute the mask
        mask_pix_exten (int): How many pixels the mask should be extended after thresholding
        mask_pix_soft (int): How many pixels the mask should be softened after extension
    Returns:
        Tuple[np.ndarray, float]:
    &#34;&#34;&#34;
    cmd = (f&#34;{osp.join(self.relionBinDir, &#39;relion_mask_create&#39;)}  --o {maskFname} &#34;
           f&#34;--i  {volFname} --ini_threshold  {volThr} &#34;
           f&#34;--extend_inimask  {mask_pix_exten} &#34;
           f&#34;--width_soft_edge {mask_pix_exten} mask_pix_soft {mask_pix_soft} &#34;
           f&#34;--lowpass  {lowpass_res} --j {self.n_cpus} &#34;)

    if self.verbose:
        print(&#34; &#34;.join(cmd))
    subprocess.run(cmd.split(), check=True, capture_output=not self.verbose)
    with mrcfile.open(maskFname) as f:
        return f.data.copy()</code></pre>
</details>
</dd>
<dt id="cesped.evaluateEntry.Evaluator.preparePredStar"><code class="name flex">
<span>def <span class="ident">preparePredStar</span></span>(<span>self, referStarFname: str, predStarFname: str, outname: str, symmetry: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Transplants pose parameters not predicted by the model from the ground-truth pose data. Then compute
angular errors comparing transplated poses with ground-truth poses</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>referStarFname</code></strong> :&ensp;<code>str</code></dt>
<dd>The file with the ground-truth poses</dd>
<dt><strong><code>predStarFname</code></strong> :&ensp;<code>str</code></dt>
<dd>The file with the predicted poses</dd>
<dt><strong><code>outname</code></strong> :&ensp;<code>str</code></dt>
<dd>The name for the transplated poses.</dd>
<dt><strong><code>symmetry</code></strong> :&ensp;<code>str</code></dt>
<dd>The point symmetry of the dataset.</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preparePredStar(self, referStarFname: str, predStarFname: str, outname: str, symmetry: str):
    &#34;&#34;&#34;
    Transplants pose parameters not predicted by the model from the ground-truth pose data. Then compute
    angular errors comparing transplated poses with ground-truth poses

    Args:
        referStarFname (str): The file with the ground-truth poses
        predStarFname (str): The file with the predicted poses
        outname (str): The name for the transplated poses.
        symmetry (str): The point symmetry of the dataset.

    Returns:

    &#34;&#34;&#34;

    if self.predictionType == &#34;S2&#34;:
        predicted_keys = RELION_ANGLES_NAMES[:2].copy()
    elif self.predictionType == &#34;SO3&#34;:
        predicted_keys = RELION_ANGLES_NAMES.copy()
    elif self.predictionType == &#34;SO3xR2&#34;:
        predicted_keys = RELION_ANGLES_NAMES.copy() + RELION_SHIFTS_NAMES.copy()
    else:
        raise ValueError(f&#34;Error, predictionType option {self.predictionType} is not valid&#34;)
    if self.usePredConfidence:
        predicted_keys += [RELION_PRED_POSE_CONFIDENCE_NAME]

    referData = starfile.read(referStarFname)
    if RELION_PRED_POSE_CONFIDENCE_NAME not in referData[&#34;particles&#34;]:
        referData[&#34;particles&#34;][RELION_PRED_POSE_CONFIDENCE_NAME] = 1.
    predData = starfile.read(predStarFname)
    if RELION_PRED_POSE_CONFIDENCE_NAME not in predData[&#34;particles&#34;]:
        predData[&#34;particles&#34;][RELION_PRED_POSE_CONFIDENCE_NAME] = 1.

    referData[&#34;particles&#34;] = referData[&#34;particles&#34;].sort_values(by=RELION_IMAGE_FNAME).reset_index(drop=True)
    predData[&#34;particles&#34;] = predData[&#34;particles&#34;].sort_values(by=RELION_IMAGE_FNAME).reset_index(drop=True)
    assert referData[&#34;particles&#34;][RELION_IMAGE_FNAME].equals(predData[&#34;particles&#34;][RELION_IMAGE_FNAME]), \
        (f&#34;Error, there is a mismatch between the ids of the predicted {predStarFname} data and the benchmark&#34;
         f&#34; data {referStarFname}&#34;)

    predAngles = predData[&#34;particles&#34;][RELION_ANGLES_NAMES].values
    gtAngles = referData[&#34;particles&#34;][RELION_ANGLES_NAMES].values
    assert predAngles.shape[0] == gtAngles.shape[0], (&#34;Error, mismatch in the number of predicted particles and gt&#34;
                                                      f&#34;particles for {referStarFname} {predStarFname}&#34;)
    meanAngularError, wMeanAngularError, totalConf = computeAngularError(
        predAngles, gtAngles,
        confidence=referData[&#34;particles&#34;][RELION_ORI_POSE_CONFIDENCE_NAME].values,
        symmetry=symmetry)

    n_elems = len(referData[&#34;particles&#34;][RELION_SHIFTS_NAMES].values)
    shiftsRMSE = np.linalg.norm(predData[&#34;particles&#34;][RELION_SHIFTS_NAMES].values -
                                referData[&#34;particles&#34;][RELION_SHIFTS_NAMES].values) / np.sqrt(n_elems)

    result = referData.copy()
    result[&#34;particles&#34;] = result[&#34;particles&#34;].copy()
    result[&#34;particles&#34;][predicted_keys] = predData[&#34;particles&#34;][predicted_keys]
    if outname is not None:
        starfile.write(result, outname)
    return result, meanAngularError, wMeanAngularError, shiftsRMSE, totalConf</code></pre>
</details>
</dd>
<dt id="cesped.evaluateEntry.Evaluator.reconstruct"><code class="name flex">
<span>def <span class="ident">reconstruct</span></span>(<span>self, starFname: str, outname: str, particlesDir: str, symmetry: str = 'c1', cleanExisting: bool = True) ‑> Tuple[numpy.ndarray, float]</span>
</code></dt>
<dd>
<div class="desc"><p>Reconstruct a volume from the information contained in a starfile.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>starFname</code></strong></dt>
<dd>The starfile with the information to be reconstructed</dd>
<dt><strong><code>outname</code></strong></dt>
<dd>The .mrc file where the reconstructed volume will be saved</dd>
<dt><strong><code>particlesDir</code></strong> :&ensp;<code>str</code></dt>
<dd>particlesDir</dd>
<dt><strong><code>symmetry</code></strong></dt>
<dd>The point symmetry of the dataset.</dd>
<dt><strong><code>cleanExisting</code></strong></dt>
<dd>True if an existing file should be removed</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Tuple[np.ndarray, float]:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reconstruct(self, starFname: str, outname: str, particlesDir: str, symmetry: str = &#34;c1&#34;,
                cleanExisting: bool = True) -&gt; Tuple[np.ndarray, float]:
    &#34;&#34;&#34;
    Reconstruct a volume from the information contained in a starfile.
    Args:
        starFname: The starfile with the information to be reconstructed
        outname: The .mrc file where the reconstructed volume will be saved
        particlesDir (str): particlesDir
        symmetry: The point symmetry of the dataset.
        cleanExisting: True if an existing file should be removed
    Returns:
        Tuple[np.ndarray, float]:
    &#34;&#34;&#34;
    with tempfile.TemporaryDirectory() as tmpdir:
        exists = osp.isfile(outname)
        if exists and cleanExisting:
            os.unlink(outname)
            exists = False
        if not exists:
            cmd = []
            wdir = particlesDir if particlesDir else osp.dirname(starFname)
            if self.relionSingularity:
                cmd += [self.relionSingularity, str(self.n_cpus)]
                destination = osp.join(tmpdir, osp.basename(wdir))
                shutil.copytree(wdir, destination)
                baseStar = osp.basename(starFname)
                shutil.copy(starFname, destination)
                starFname = osp.join(destination, baseStar)
                wdir = destination
            else:
                if self.n_cpus &gt; 1:
                    cmd += self.mpirun.split() + [&#34;-np&#34;, str(self.n_cpus),
                                                  osp.join(self.relionBinDir, &#34;relion_reconstruct_mpi&#34;)]
                else:
                    cmd += [osp.join(self.relionBinDir, &#34;relion_reconstruct&#34;)]

            with tempfile.NamedTemporaryFile(suffix=&#34;.mrc&#34;) as f:
                cmd += [&#34;--i&#34;, starFname, &#34;--o&#34;, f.name, &#34;--ctf&#34;, &#34;--sym&#34;, symmetry.lower(), &#34;--pad&#34;, &#34;2.0&#34;]
                if self.usePredConfidence:
                    data = starfile.read(starFname)
                    if RELION_PRED_POSE_CONFIDENCE_NAME in data[&#34;particles&#34;]:
                        cmd += [&#34;--fom_weighting&#34;]
                if self.verbose:
                    print(&#34; &#34;.join(cmd))
                subprocess.run(cmd, cwd=wdir, check=True, capture_output=not self.verbose)
                f.seek(0)
                shutil.copyfile(f.name, outname)
        else:
            print(f&#34;Reusing file {outname}&#34;)
        with mrcfile.open(outname) as f:
            data = f.data.copy()
            sampling_rate = float(f.voxel_size.x)
    return data, sampling_rate</code></pre>
</details>
</dd>
<dt id="cesped.evaluateEntry.Evaluator.runEvaluate"><code class="name flex">
<span>def <span class="ident">runEvaluate</span></span>(<span>self, targetName, half0PredsFname, half1PredsFname, rm_prev_reconstructions, ignore_symmetry)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    def runEvaluate(self, targetName, half0PredsFname, half1PredsFname, rm_prev_reconstructions, ignore_symmetry):

        with (tempfile.TemporaryDirectory() as tmpdir):
            if self.wdir is None:
                wdir = tmpdir
            else:
                wdir = self.wdir
                os.makedirs(wdir, exist_ok=True)

            os.makedirs(wdir, exist_ok=True)
            ps0 = ParticlesDataset(targetName, halfset=0, benchmarkDir=self.benchmarkDir)
            ps1 = ParticlesDataset(targetName, halfset=1, benchmarkDir=self.benchmarkDir)

            # GET MASK
            if self.use_gt_mask:
                print(&#34;Downloading mask&#34;)
                mask_fname = osp.join(wdir, &#34;mask.mrc&#34;)
                download_mask(targetName, mask_fname)
            else:
                mask_fname = None

            symmetry = ps0.symmetry if not ignore_symmetry else &#34;C1&#34;
            gt_map, gt_sampling, gt_cor, gt_resolt0143, gt_resolt05 = self.computeAvgMap(ps0.starFname, ps1.starFname,
                                                                                         particlesDir=ps0.datadir,
                                                                                         outbasename=&#34;gt&#34;,
                                                                                         symmetry=symmetry,
                                                                                         cleanExisting=False,
                                                                                         mask=mask_fname)
            prepStarFname0 = osp.join(tmpdir, &#34;prepStarFname0.star&#34;)
            _, meanAngularError0, wMeanAngularError0, shiftsRMSE0, totalConf0 = \
                self.preparePredStar(ps0.starFname, half0PredsFname, prepStarFname0, symmetry)
            prepStarFname1 = osp.join(tmpdir, &#34;prepStarFname1.star&#34;)
            _, meanAngularError1, wMeanAngularError1, shiftsRMSE1, totalConf1 = \
                self.preparePredStar(ps1.starFname, half1PredsFname, prepStarFname1, symmetry)

            meanAngularError = .5 * (meanAngularError0 + meanAngularError1)
            wMeanAngularError = (totalConf0 * wMeanAngularError0 + totalConf1 * wMeanAngularError1) / (
                    totalConf0 + totalConf1)
            shiftsRMSE = .5 * (shiftsRMSE0 + shiftsRMSE1)

            assert ps0.datadir == ps1.datadir
            pred_map, pred_sampling, pred_corr, pred_resolut, pred_resolt05 = self.computeAvgMap(
                prepStarFname0, prepStarFname1,
                particlesDir=ps0.datadir, outbasename=&#34;pred&#34;,
                symmetry=symmetry, cleanExisting=rm_prev_reconstructions, mask=mask_fname)

            if self.verbose:
                print(&#34;Computing statistics...&#34;)
            mapVsGT_cor, (mapVsGT_resolt, m_mapVsGT_resolt, *_) = compute_stats(gt_map, pred_map,
                                                                                samplingRate=gt_sampling,
                                                                                resolution_threshold=0.143,
                                                                                maskOrFname=mask_fname)
            _, (mapVsGT_resolt05, m_mapVsGT_resolt05, *_) = compute_stats(gt_map, pred_map,
                                                                          samplingRate=gt_sampling,
                                                                          resolution_threshold=0.5,
                                                                          maskOrFname=mask_fname)
            cor_diff = (gt_cor - mapVsGT_cor) #/ gt_cor

            res_diff05 = mapVsGT_resolt05 - gt_resolt05
            res_diff = mapVsGT_resolt - gt_resolt0143


            metrics = dict(meanAngularError=meanAngularError, wMeanAngularError=wMeanAngularError,
                           shiftsRMSE=shiftsRMSE,
                           GT_correlation=gt_cor,
                           GT_resolution0143=gt_resolt0143, GT_resolution05=gt_resolt05,
                           half2half_resolution=pred_resolut, half2half_resolution05=pred_resolt05,
                           half2half_correlation=pred_corr,
                           mapVsGT_correlaton_masked=mapVsGT_cor[1], mapVsGT_correlaton_unmasked=mapVsGT_cor[0],
                           mapVsGT_resolution=mapVsGT_resolt, mapVsGT_resolution05=mapVsGT_resolt05,
                           )

            with open(osp.join(self.wdir, &#34;metrics.json&#34;), &#34;w&#34;) as f:
                json.dump(metrics, f)

            report_str = f&#34;&#34;&#34;
&gt; EVALUATION for target:                  {targetName}
GT_correlation:                           {gt_cor}
GT_resolution (Å) (th=0.143, 0.5):        {gt_resolt0143}  {gt_resolt05}
&gt; RESULTS
#Predictions
mean_angular_error (°):                   {meanAngularError} 
w_mean_angular_error (°):                 {wMeanAngularError} 
shifts_RMSE (Å):                          {shiftsRMSE}
#Reconstruction
half2half_correlation:                    {pred_corr}
half2half_resolution (Å) (th=0.143, 0.5): {pred_resolut}  {pred_resolt05}
mapVsGT_correlaton (masked, unmasked):    {&#34;  &#34;.join(reversed([str(x) for x in mapVsGT_cor]))}
mapVsGT_resolution (Å) (th=0.143, 0.5)    {mapVsGT_resolt}  {mapVsGT_resolt05}
#Reconstruction differences
cor_diff (%) (masked, unmasked):          {&#34;  &#34;.join(reversed([str(x * 100) for x in cor_diff]))}
res_diff (Å) th=0.143, 0.5):              {res_diff}  {res_diff05}
            &#34;&#34;&#34;

            if self.verbose:
                print(report_str)
            return metrics</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cesped" href="index.html">cesped</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="cesped.evaluateEntry.evaluate" href="#cesped.evaluateEntry.evaluate">evaluate</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cesped.evaluateEntry.Evaluator" href="#cesped.evaluateEntry.Evaluator">Evaluator</a></code></h4>
<ul class="">
<li><code><a title="cesped.evaluateEntry.Evaluator.computeAvgMap" href="#cesped.evaluateEntry.Evaluator.computeAvgMap">computeAvgMap</a></code></li>
<li><code><a title="cesped.evaluateEntry.Evaluator.computeMask" href="#cesped.evaluateEntry.Evaluator.computeMask">computeMask</a></code></li>
<li><code><a title="cesped.evaluateEntry.Evaluator.preparePredStar" href="#cesped.evaluateEntry.Evaluator.preparePredStar">preparePredStar</a></code></li>
<li><code><a title="cesped.evaluateEntry.Evaluator.reconstruct" href="#cesped.evaluateEntry.Evaluator.reconstruct">reconstruct</a></code></li>
<li><code><a title="cesped.evaluateEntry.Evaluator.runEvaluate" href="#cesped.evaluateEntry.Evaluator.runEvaluate">runEvaluate</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>